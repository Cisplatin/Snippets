"""
Distinct Primes Factors
Problem 47
"""

# We use an arbitrary upper bound, and throw an error if it's not high enough
LOWER_BOUND = 2
UPPER_BOUND = 100
DISTINCT_DIVISORS = 2

# We save some time by finding all primes, as we know that each of them has
# only one divisor (itself). We also use these to calculate divisors
def prime_sieves():
    erato, primes, exists = [True] * UPPER_BOUND, [], {}
    for i in xrange(2, UPPER_BOUND):
        if erato[i]:
            # We found a prime, so switch off all multiples
            primes.append(i)
            exists[i] = True
            for j in xrange(i, UPPER_BOUND, i):
                erato[j] = False
    return (primes, exists)
primes, exists = prime_sieves()

# We now go through each number and count the divisors. If it has four
# factors, we add to the count
count = 0
for n in xrange(LOWER_BOUND, UPPER_BOUND):
    # Find the number of divisors by using the fact that the number of divisors
    # is equal to the product of all prime multiples plus one
    index, distinct = 0, 0
    while n > 1 and n not in exists:
        if n % primes[index] == 0:
            print n
            # If it divides, we have found a distinct prime factor
            while n % primes[index] == 0:
                n /= primes[index]
            distinct += 1
        index += 1

    # If the number is not equal to one by now, then it's a prime, so we
    # account for that in the divisors count
    if n > 1:
        distinct += 1

    # If the divisors match up, add to the count
    if distinct == DISTINCT_DIVISORS:
        count += 1
    else:
        count = 0

    # If we have found the end, then finish
    if count == DISTINCT_DIVISORS:
        print n
        break
